/*
 * Copyright (c) 2016-2017 Threema GmbH
 *
 * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>
 * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be
 * copied, modified, or distributed except according to those terms.
 */

package org.saltyrtc.client.tests.keystore;

import org.junit.Before;
import org.junit.Test;
import org.saltyrtc.client.exceptions.CryptoFailedException;
import org.saltyrtc.client.exceptions.InvalidKeyException;
import org.saltyrtc.client.helpers.HexHelper;
import org.saltyrtc.client.helpers.RandomHelper;
import org.saltyrtc.client.helpers.UnsignedHelper;
import org.saltyrtc.client.keystore.Box;
import org.saltyrtc.client.keystore.KeyStore;
import org.saltyrtc.vendor.com.neilalexander.jnacl.NaCl;

import java.security.SecureRandom;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.fail;

public class KeyStoreTest {

    private KeyStore ks;
    private SecureRandom random = new SecureRandom();

    @Before
    public void setUp() throws Exception {
        this.ks = new KeyStore();
    }

    @Test
    public void testEncrypt() throws CryptoFailedException, InvalidKeyException {
        final byte[] in = "hello".getBytes();
        final byte[] nonce = new byte[NaCl.NONCEBYTES];
        final byte[] otherKey = new byte[NaCl.PUBLICKEYBYTES];
        this.random.nextBytes(nonce);
        this.random.nextBytes(otherKey);
        final Box box = this.ks.encrypt(in, nonce, otherKey);
        assertEquals(nonce, box.getNonce());
        assertNotEquals(in, box.getData());
    }

    @Test
    public void testDecrypt() throws CryptoFailedException, InvalidKeyException {
        // The following values have been generated by logging the values in the encrypt test.
        final byte[] privateKey = {98, -128, 32, -16, -93, -3, 90, -19, -62, -45, -89, -120, 0, 54, -31, -52, -88, 83, -51, -7, 84, 60, 101, 94, 33, 21, -57, 7, 51, 5, 61, 34};
        final byte[] nonce = {110, -111, 24, -87, 127, 91, 87, -121, 119, 13, -23, 14, -88, -12, -30, -73, -88, -112, -65, -76, -73, -11, 64, 37};
        final byte[] otherKey = {34, 81, 26, 50, -112, 8, -78, -80, 76, -66, -91, 31, 122, -98, 102, -24, -56, -40, -2, -115, -110, -23, 95, 47, 51, 25, 77, 59, 59, -11, -120, 100};
        final byte[] encrypted = {-39, -59, 107, -111, -84, 49, 71, -67, 63, -28, -94, 40, 48, 121, 68, -40, 63, 102, 9, 90, 97};
        // Decrypt
        this.ks = new KeyStore(privateKey);
        final Box box = new Box(nonce, encrypted);
        final byte[] decrypted = this.ks.decrypt(box, otherKey);
        assertArrayEquals("hello".getBytes(), decrypted);
    }

    @Test(expected=CryptoFailedException.class)
    public void testDecryptFails() throws InvalidKeyException, CryptoFailedException {
        // Encrypt data
        final byte[] in = "hello".getBytes();
        final byte[] nonce = new byte[NaCl.NONCEBYTES];
        final byte[] otherKey = new byte[NaCl.PUBLICKEYBYTES];
        this.random.nextBytes(nonce);
        this.random.nextBytes(otherKey);
        final Box box = this.ks.encrypt(in, nonce, otherKey);

        // Decrypt successfully
        try {
            final byte[] decrypted1 = this.ks.decrypt(box, otherKey);
            assertArrayEquals("hello".getBytes(), decrypted1);
        } catch (CryptoFailedException e) {
            fail("Decryption failed, but shouldn't");
        }

        // Now decrypt with wrong keys
        this.ks = new KeyStore();
        // This will now fail with a CryptFailedException
        this.ks.decrypt(box, otherKey);
    }

    @Test(expected=InvalidKeyException.class)
    public void testInvalidKey() throws InvalidKeyException, CryptoFailedException {
        final byte[] in = "hello".getBytes();
        final byte[] nonce = new byte[NaCl.NONCEBYTES];
        final byte[] otherKey = {42};
        this.random.nextBytes(nonce);
        this.ks.encrypt(in, nonce, otherKey);
    }

    @Test
    public void testHexConstructor() {
        final short[] shorts = { 0x00, 0x01, 0x02, 0xff, 0xff, 0xff, 0xff, 0xff,
                                 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        byte[] bytes = new byte[32];
        for (int i = 0; i < 32; i++) {
            bytes[i] = UnsignedHelper.getUnsignedByte(shorts[i]);
        }

        // Make sure hex and bytes are the same
        final String hex = "000102ffffffffffffffffffffffffffffffffffffffffff0000000000000000";
        assertArrayEquals(bytes, HexHelper.hexStringToByteArray(hex));

        // Create keystore with both bytes and hex string
        final KeyStore ks1 = new KeyStore(bytes);
        final KeyStore ks2 = new KeyStore(hex);
        assertArrayEquals(ks1.getPublicKey(), ks2.getPublicKey());
        final KeyStore ks3 = new KeyStore(bytes, RandomHelper.pseudoRandomBytes(32));
        final KeyStore ks4 = new KeyStore(hex, hex);
        assertArrayEquals(ks3.getPublicKey(), ks4.getPublicKey());
    }

    @Test
    public void testHexKeys() {
        final String skHex = "000102ffffffffffffffffffffffffffffffffffffffffff0000000000000000";
        final String pkHex = "80fff5050d2822b5ca66d0525ed98f55fc24b3e152d20153848d409905fb9023";
        this.ks = new KeyStore(skHex);
        assertEquals(this.ks.getPrivateKeyHex(), skHex);
        assertEquals(this.ks.getPublicKeyHex(), pkHex);
    }

}
